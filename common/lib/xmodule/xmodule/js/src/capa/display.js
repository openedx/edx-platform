// Generated by CoffeeScript 1.6.1
(function () {
    var _this = this,
        __indexOf = [].indexOf || function (item) {
                for (var i = 0, l = this.length; i < l; i++) {
                    if (i in this && this[i] === item) return i;
                }
                return -1;
            };

    this.Problem = (function () {
        var _this = this;

        function Problem(element) {
            var _this = this;
            this.hint_button = function () {
                return Problem.prototype.hint_button.apply(_this, arguments);
            };
            this.enableSubmitButtonAfterTimeout = function () {
                return Problem.prototype.enableSubmitButtonAfterTimeout.apply(_this, arguments);
            };
            this.enableSubmitButtonAfterResponse = function () {
                return Problem.prototype.enableSubmitButtonAfterResponse.apply(_this, arguments);
            };
            this.enableSubmitButton = function (enable, changeText) {
                if (changeText == null) {
                    changeText = true;
                }
                return Problem.prototype.enableSubmitButton.apply(_this, arguments);
            };
            this.enableAllButtons = function (enable, isFromCheckOperation) {
                return Problem.prototype.enableAllButtons.apply(_this, arguments);
            };
            this.disableAllButtonsWhileRunning = function (operationCallback, isFromCheckOperation) {
                return Problem.prototype.disableAllButtonsWhileRunning.apply(_this, arguments);
            };
            this.submitAnswersAndSubmitButton = function (bind) {
                if (bind == null) {
                    bind = false;
                }
                return Problem.prototype.submitAnswersAndSubmitButton.apply(_this, arguments);
            };
            this.refreshAnswers = function () {
                return Problem.prototype.refreshAnswers.apply(_this, arguments);
            };
            this.updateMathML = function (jax, element) {
                return Problem.prototype.updateMathML.apply(_this, arguments);
            };
            this.refreshMath = function (event, element) {
                return Problem.prototype.refreshMath.apply(_this, arguments);
            };
            this.save_internal = function () {
                return Problem.prototype.save_internal.apply(_this, arguments);
            };
            this.save = function () {
                return Problem.prototype.save.apply(_this, arguments);
            };
            this.gentle_alert = function (msg) {
                return Problem.prototype.gentle_alert.apply(_this, arguments);
            };
            this.clear_all_notifications = function () {
                return Problem.prototype.clear_all_notifications.apply(_this, arguments);
            };
            this.show = function () {
                return Problem.prototype.show.apply(_this, arguments);
            };
            this.reset_internal = function () {
                return Problem.prototype.reset_internal.apply(_this, arguments);
            };
            this.reset = function () {
                return Problem.prototype.reset.apply(_this, arguments);
            };
            this.get_sr_status = function (contents) {
                return Problem.prototype.get_sr_status.apply(_this, arguments);
            };
            this.submit_internal = function () {
                return Problem.prototype.submit_internal.apply(_this, arguments);
            };
            this.submit = function () {
                return Problem.prototype.submit.apply(_this, arguments);
            };
            this.submit_fd = function () {
                return Problem.prototype.submit_fd.apply(_this, arguments);
            };
            this.focus_on_save_notification = function () {
                return Problem.prototype.focus_on_save_notification.apply(_this, arguments);
            };
            this.focus_on_hint_notification = function () {
                return Problem.prototype.focus_on_hint_notification.apply(_this, arguments);
            };
            this.focus_on_submit_notification = function () {
                return Problem.prototype.focus_on_submit_notification.apply(_this, arguments);
            };
            this.focus_on_notification = function (type) {
                return Problem.prototype.focus_on_notification.apply(_this, arguments);
            };
            this.scroll_to_problem_meta = function () {
                return Problem.prototype.scroll_to_problem_meta.apply(_this, arguments);
            };
            this.submit_save_waitfor = function (callback) {
                return Problem.prototype.submit_save_waitfor.apply(_this, arguments);
            };
            this.setupInputTypes = function () {
                return Problem.prototype.setupInputTypes.apply(_this, arguments);
            };
            this.poll = function (prev_timeout, focus_callback) {
                return Problem.prototype.poll.apply(_this, arguments);
            };
            this.queueing = function (focus_callback) {
                return Problem.prototype.queueing.apply(_this, arguments);
            };
            this.forceUpdate = function (response) {
                return Problem.prototype.forceUpdate.apply(_this, arguments);
            };
            this.updateProgress = function (response) {
                return Problem.prototype.updateProgress.apply(_this, arguments);
            };
            this.renderProgressState = function () {
                return Problem.prototype.renderProgressState.apply(_this, arguments);
            };
            this.bind = function () {
                return Problem.prototype.bind.apply(_this, arguments);
            };
            this.el = $(element).find('.problems-wrapper');
            this.id = this.el.data('problem-id');
            this.element_id = this.el.attr('id');
            this.url = this.el.data('url');
            this.content = this.el.data('content');
            this.has_timed_out = false;
            this.has_response = false;
            this.render(this.content);
        }

        Problem.prototype.$ = function (selector) {
            return $(selector, this.el);
        };

        Problem.prototype.bind = function () {
            var problem_prefix,
                _this = this;
            if (typeof MathJax !== "undefined" && MathJax !== null) {
                this.el.find('.problem > div').each(function (index, element) {
                    return MathJax.Hub.Queue(["Typeset", MathJax.Hub, element]);
                });
            }
            window.update_schematics();
            problem_prefix = this.element_id.replace(/problem_/, '');
            this.inputs = this.$("[id^='input_" + problem_prefix + "_']");
            this.$('div.action button').click(this.refreshAnswers);
            this.reviewButton = this.$('.notification-btn.review-btn');
            this.reviewButton.click(this.scroll_to_problem_meta);
            this.submitButton = this.$('.action .submit');
            this.submitButtonLabel = this.$('.action .submit .submit-label');
            this.submitButtonSubmitText = this.submitButtonLabel.text();
            this.submitButtonSubmittingText = this.submitButton.data('submitting');
            this.submitButton.click(this.submit_fd);
            this.hintButton = this.$('.action .hint-button');
            this.hintButton.click(this.hint_button);
            this.resetButton = this.$('.action .reset');
            this.resetButton.click(this.reset);
            this.showButton = this.$('.action .show');
            this.showButton.click(this.show);
            this.saveButton = this.$('.action .save');
            this.saveNotification = this.$('.notification-save');
            this.saveButtonLabel = this.$('.action .save .save-label');
            this.saveButton.click(this.save);
            this.gentleAlertNotification = this.$('.notification-gentle-alert');
            this.submitNotification = this.$('.notification-submit');
            this.$('.clarification').focus(function (ev) {
                var icon;
                icon = $(ev.target).children("i");
                return window.globalTooltipManager.openTooltip(icon);
            });
            this.$('.clarification').blur(function (ev) {
                return window.globalTooltipManager.hide();
            });
            this.$('.review-btn').focus(function (ev) {
                return $(ev.target).removeClass('sr');
            });
            this.$('.review-btn').blur(function (ev) {
                return $(ev.target).addClass('sr');
            });
            this.bindResetCorrectness();
            if (this.submitButton.length) {
                this.submitAnswersAndSubmitButton(true);
            }
            Collapsible.setCollapsibles(this.el);
            this.$('input.math').keyup(this.refreshMath);
            if (typeof MathJax !== "undefined" && MathJax !== null) {
                return this.$('input.math').each(function (index, element) {
                    return MathJax.Hub.Queue([_this.refreshMath, null, element]);
                });
            }
        };

        Problem.prototype.renderProgressState = function () {
            var a, detail, earned, graded, possible, progress, progress_template, status;
            detail = this.el.data('progress_detail');
            status = this.el.data('progress_status');
            graded = this.el.data('graded');
            if (status !== 'none' && (detail != null) && (jQuery.type(detail) === "string") && detail.indexOf('/') > 0) {
                a = detail.split('/');
                earned = parseFloat(a[0]);
                possible = parseFloat(a[1]);
                if (graded === "True" && possible !== 0) {
                    // Translators: %(earned)s is the number of points earned. %(possible)s is the total number of points (examples: 0/1, 1/1, 2/3, 5/10). The total number of points will always be at least 1. We pluralize based on the total number of points (example: 0/1 point; 1/2 points);
                    progress_template = ngettext('%(earned)s/%(possible)s point (graded)', '%(earned)s/%(possible)s points (graded)', possible);
                } else {
                    // Translators: %(earned)s is the number of points earned. %(possible)s is the total number of points (examples: 0/1, 1/1, 2/3, 5/10). The total number of points will always be at least 1. We pluralize based on the total number of points (example: 0/1 point; 1/2 points);
                    progress_template = ngettext('%(earned)s/%(possible)s point (ungraded)', '%(earned)s/%(possible)s points (ungraded)', possible);
                }
                progress = interpolate(progress_template, {
                    'earned': earned,
                    'possible': possible
                }, true);
            }
            if (status === 'none' || status === 0) {
                if ((detail != null) && (jQuery.type(detail) === "string") && detail.indexOf('/') > 0) {
                    a = detail.split('/');
                    possible = parseFloat(a[1]);
                } else {
                    possible = 0;
                }
                if (graded === "True" && possible !== 0) {
                    // Translators: %(num_points)s is the number of points possible (examples: 1, 3, 10).;
                    progress_template = ngettext("%(num_points)s point possible (graded)", "%(num_points)s points possible (graded)", possible);
                } else {
                    // Translators: %(num_points)s is the number of points possible (examples: 1, 3, 10).;
                    progress_template = ngettext("%(num_points)s point possible (ungraded)", "%(num_points)s points possible (ungraded)", possible);
                }
                progress = interpolate(progress_template, {
                    'num_points': possible
                }, true);
            }
            return this.$('.problem-progress').text(progress);
        };

        Problem.prototype.updateProgress = function (response) {
            if (response.progress_changed) {
                this.el.data('progress_status', response.progress_status);
                this.el.data('progress_detail', response.progress_detail);
                this.el.trigger('progressChanged');
            }
            return this.renderProgressState();
        };

        Problem.prototype.forceUpdate = function (response) {
            this.el.data('progress_status', response.progress_status);
            this.el.data('progress_detail', response.progress_detail);
            this.el.trigger('progressChanged');
            return this.renderProgressState();
        };

        Problem.prototype.queueing = function (focus_callback) {
            var _this = this;
            this.queued_items = this.$(".xqueue");
            this.num_queued_items = this.queued_items.length;
            if (this.num_queued_items > 0) {
                if (window.queuePollerID) {
                    window.clearTimeout(window.queuePollerID);
                }
                return window.queuePollerID = window.setTimeout(function () {
                    return _this.poll(1000, focus_callback);
                }, 1000);
            }
        };

        Problem.prototype.poll = function (prev_timeout, focus_callback) {
            var _this = this;
            return $.postWithPrefix("" + this.url + "/problem_get", function (response) {
                var new_timeout;
                _this.new_queued_items = $(response.html).find(".xqueue");
                if (_this.new_queued_items.length !== _this.num_queued_items) {
                    edx.HtmlUtils.setHtml(_this.el, edx.HtmlUtils.HTML(response.html)).promise().done(function () {
                        return typeof focus_callback === "function" ? focus_callback() : void 0;
                    });
                    JavascriptLoader.executeModuleScripts(_this.el, function () {
                        _this.setupInputTypes();
                        return _this.bind();
                    });
                }
                _this.num_queued_items = _this.new_queued_items.length;
                if (_this.num_queued_items === 0) {
                    _this.forceUpdate(response);
                    return delete window.queuePollerID;
                } else {
                    new_timeout = prev_timeout * 2;
                    if (new_timeout >= 60000) {
                        delete window.queuePollerID;
                        return _this.gentle_alert(gettext("The grading process is still running. Refresh the page to see updates."));
                    } else {
                        return window.queuePollerID = window.setTimeout(function () {
                            return _this.poll(new_timeout, focus_callback);
                        }, new_timeout);
                    }
                }
            });
        };

        Problem.inputAjax = function (url, input_id, dispatch, data, callback) {
            data['dispatch'] = dispatch;
            data['input_id'] = input_id;
            return $.postWithPrefix("" + url + "/input_ajax", data, callback);
        };

        Problem.prototype.render = function (content, focus_callback) {
            var _this = this;
            if (content) {
                this.el.html(content);
                return JavascriptLoader.executeModuleScripts(this.el, function () {
                    _this.setupInputTypes();
                    _this.bind();
                    _this.queueing(focus_callback);
                    _this.renderProgressState();
                    return typeof focus_callback === "function" ? focus_callback() : void 0;
                });
            } else {
                return $.postWithPrefix("" + this.url + "/problem_get", function (response) {
                    _this.el.html(response.html);
                    return JavascriptLoader.executeModuleScripts(_this.el, function () {
                        _this.setupInputTypes();
                        _this.bind();
                        _this.queueing();
                        return _this.forceUpdate(response);
                    });
                });
            }
        };

        Problem.prototype.setupInputTypes = function () {
            var _this = this;
            this.inputtypeDisplays = {};
            return this.el.find(".capa_inputtype").each(function (index, inputtype) {
                var classes, cls, id, setupMethod, _i, _len, _results;
                classes = $(inputtype).attr('class').split(' ');
                id = $(inputtype).attr('id');
                _results = [];
                for (_i = 0, _len = classes.length; _i < _len; _i++) {
                    cls = classes[_i];
                    setupMethod = _this.inputtypeSetupMethods[cls];
                    if (setupMethod != null) {
                        _results.push(_this.inputtypeDisplays[id] = setupMethod(inputtype));
                    } else {
                        _results.push(void 0);
                    }
                }
                return _results;
            });
        };

        Problem.prototype.submit_save_waitfor = function (callback) {
            var flag, inp, _i, _len, _ref,
                _this = this;
            flag = false;
            _ref = this.inputs;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                inp = _ref[_i];
                if ($(inp).is("input[waitfor]")) {
                    try {
                        $(inp).data("waitfor")(function () {
                            _this.refreshAnswers();
                            return callback();
                        });
                    } catch (e) {
                        if (e.name === "Waitfor Exception") {
                            alert(e.message);
                        } else {
                            alert("Could not grade your answer. The submission was aborted.");
                        }
                        throw e;
                    }
                    flag = true;
                } else {
                    flag = false;
                }
            }
            return flag;
        };

        Problem.prototype.scroll_to_problem_meta = function () {
            var questionTitle;
            questionTitle = this.$(".problem-header");
            if (questionTitle.length > 0) {
                $('html, body').animate({
                    scrollTop: questionTitle.offset().top
                }, 500);
                return questionTitle.focus();
            }
        };

        Problem.prototype.focus_on_notification = function (type) {
            var notification;
            notification = this.$('.notification-' + type);
            if (notification.length > 0) {
                return notification.focus();
            }
        };

        Problem.prototype.focus_on_submit_notification = function () {
            return this.focus_on_notification('submit');
        };

        Problem.prototype.focus_on_hint_notification = function () {
            return this.focus_on_notification('hint');
        };

        Problem.prototype.focus_on_save_notification = function () {
            return this.focus_on_notification('save');
        };

        /*
         # 'submit_fd' uses FormData to allow file submissions in the 'problem_check' dispatch,
         #      in addition to simple querystring-based answers
         #
         # NOTE: The dispatch 'problem_check' is being singled out for the use of FormData;
         #       maybe preferable to consolidate all dispatches to use FormData
         */


        Problem.prototype.submit_fd = function () {
            var abort_submission, error, error_html, errors, fd, file_not_selected, file_too_large, max_filesize, required_files_not_submitted, settings, timeout_id, unallowed_file_submitted, _i, _len,
                _this = this;
            if (this.el.find('input:file').length === 0) {
                this.submit();
                return;
            }
            this.enableSubmitButton(false);
            if (!window.FormData) {
                alert("Submission aborted! Sorry, your browser does not support file uploads. If you can, please use Chrome or Safari which have been verified to support file uploads.");
                this.enableSubmitButton(true);
                return;
            }
            timeout_id = this.enableSubmitButtonAfterTimeout();
            fd = new FormData();
            max_filesize = 4 * 1000 * 1000;
            file_too_large = false;
            file_not_selected = false;
            required_files_not_submitted = false;
            unallowed_file_submitted = false;
            errors = [];
            this.inputs.each(function (index, element) {
                var allowed_files, file, max_size, required_files, _i, _len, _ref, _ref1, _ref2;
                if (element.type === 'file') {
                    required_files = $(element).data("required_files");
                    allowed_files = $(element).data("allowed_files");
                    _ref = element.files;
                    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                        file = _ref[_i];
                        if (allowed_files.length !== 0 && (_ref1 = file.name, __indexOf.call(allowed_files, _ref1) < 0)) {
                            unallowed_file_submitted = true;
                            errors.push("You submitted " + file.name + "; only " + allowed_files + " are allowed.");
                        }
                        if (_ref2 = file.name, __indexOf.call(required_files, _ref2) >= 0) {
                            required_files.splice(required_files.indexOf(file.name), 1);
                        }
                        if (file.size > max_filesize) {
                            file_too_large = true;
                            max_size = max_filesize / (1000 * 1000);
                            errors.push("Your file " + file.name + " is too large (max size: {max_size}MB)");
                        }
                        fd.append(element.id, file);
                    }
                    if (element.files.length === 0) {
                        file_not_selected = true;
                        fd.append(element.id, '');
                    }
                    if (required_files.length !== 0) {
                        required_files_not_submitted = true;
                        return errors.push("You did not submit the required files: " + required_files + ".");
                    }
                } else {
                    return fd.append(element.id, element.value);
                }
            });
            if (file_not_selected) {
                errors.push('You did not select any files to submit');
            }
            error_html = '<ul>\n';
            for (_i = 0, _len = errors.length; _i < _len; _i++) {
                error = errors[_i];
                error_html += '<li>' + error + '</li>\n';
            }
            error_html += '</ul>';
            this.gentle_alert(error_html);
            abort_submission = file_too_large || file_not_selected || unallowed_file_submitted || required_files_not_submitted;
            if (abort_submission) {
                window.clearTimeout(timeout_id);
                this.enableSubmitButton(true);
                return;
            }
            settings = {
                type: "POST",
                data: fd,
                processData: false,
                contentType: false,
                complete: this.enableSubmitButtonAfterResponse,
                success: function (response) {
                    switch (response.success) {
                        case 'incorrect':
                        case 'correct':
                            _this.render(response.contents);
                            _this.updateProgress(response);
                            break;
                        default:
                            _this.gentle_alert(response.success);
                    }
                    return Logger.log('problem_graded', [_this.answers, response.contents], _this.id);
                }
            };
            return $.ajaxWithPrefix("" + this.url + "/problem_check", settings);
        };

        Problem.prototype.submit = function () {
            if (!this.submit_save_waitfor(this.submit_internal)) {
                return this.disableAllButtonsWhileRunning(this.submit_internal, true);
            }
        };

        Problem.prototype.submit_internal = function () {
            var _this = this;
            Logger.log('problem_check', this.answers);
            return $.postWithPrefix("" + this.url + "/problem_check", this.answers, function (response) {
                switch (response.success) {
                    case 'incorrect':
                    case 'correct':
                        window.SR.readTexts(_this.get_sr_status(response.contents));
                        _this.el.trigger('contentChanged', [_this.id, response.contents]);
                        _this.render(response.contents, _this.focus_on_submit_notification);
                        _this.updateProgress(response);
                        break;
                    default:
                        _this.saveNotification.hide();
                        _this.gentle_alert(response.success);
                }
                return Logger.log('problem_graded', [_this.answers, response.contents], _this.id);
            });
        };

        Problem.prototype.get_sr_status = function (contents) {
            var added_status, aria_label, element, labeled_status, parent_section, status_elements, template, _i, _len;
            status_elements = $(contents).find('.status');
            labeled_status = [];
            for (_i = 0, _len = status_elements.length; _i < _len; _i++) {
                element = status_elements[_i];
                parent_section = $(element).closest('section');
                added_status = false;
                if (parent_section) {
                    aria_label = parent_section.attr('aria-label');
                    if (aria_label) {
                        // Translators: This is only translated to allow for reording of label and associated status.;
                        template = gettext("{label}: {status}");
                        labeled_status.push(edx.StringUtils.interpolate(template, {
                            label: aria_label,
                            status: $(element).text()
                        }));
                        added_status = true;
                    }
                }
                if (!added_status) {
                    labeled_status.push($(element).text());
                }
            }
            return labeled_status;
        };

        Problem.prototype.reset = function () {
            return this.disableAllButtonsWhileRunning(this.reset_internal, false);
        };

        Problem.prototype.reset_internal = function () {
            var _this = this;
            Logger.log('problem_reset', this.answers);
            return $.postWithPrefix("" + this.url + "/problem_reset", {
                id: this.id
            }, function (response) {
                if (response.success) {
                    _this.el.trigger('contentChanged', [_this.id, response.html]);
                    _this.render(response.html, _this.scroll_to_problem_meta);
                    _this.updateProgress(response);
                    return window.SR.readText(gettext('This problem has been reset.'));
                } else {
                    return _this.gentle_alert(response.msg);
                }
            });
        };

        Problem.prototype.show = function () {
            var _this = this;
            Logger.log('problem_show', {
                problem: this.id
            });
            return $.postWithPrefix("" + this.url + "/problem_show", function (response) {
                var answers;
                answers = response.answers;
                $.each(answers, function (key, value) {
                    var answer, choice, solution, _i, _len, _results;
                    if ($.isArray(value)) {
                        _results = [];
                        for (_i = 0, _len = value.length; _i < _len; _i++) {
                            choice = value[_i];
                            _results.push(_this.$("label[for='input_" + key + "_" + choice + "']").attr({
                                correct_answer: 'true'
                            }));
                        }
                        return _results;
                    } else {
                        answer = _this.$("#answer_" + key + ", #solution_" + key);
                        edx.HtmlUtils.setHtml(answer, edx.HtmlUtils.HTML(value));
                        Collapsible.setCollapsibles(answer);
                        try {
                            return solution = $(value).find('.detailed-solution');
                        } catch (e) {
                            return solution = {};
                        }
                    }
                });
                _this.el.find(".capa_inputtype").each(function (index, inputtype) {
                    var classes, cls, display, showMethod, _i, _len, _results;
                    classes = $(inputtype).attr('class').split(' ');
                    _results = [];
                    for (_i = 0, _len = classes.length; _i < _len; _i++) {
                        cls = classes[_i];
                        display = _this.inputtypeDisplays[$(inputtype).attr('id')];
                        showMethod = _this.inputtypeShowAnswerMethods[cls];
                        if (showMethod != null) {
                            _results.push(showMethod(inputtype, display, answers));
                        } else {
                            _results.push(void 0);
                        }
                    }
                    return _results;
                });
                if (typeof MathJax !== "undefined" && MathJax !== null) {
                    _this.el.find('.problem > div').each(function (index, element) {
                        return MathJax.Hub.Queue(["Typeset", MathJax.Hub, element]);
                    });
                }
                _this.el.find('.show').attr('disabled', 'disabled');
                _this.updateProgress(response);
                window.SR.readText(gettext('Answers to this problem are now shown. Navigate through the problem to review it with answers inline.'));
                return _this.scroll_to_problem_meta();
            });
        };

        Problem.prototype.clear_all_notifications = function () {
            this.submitNotification.remove();
            this.gentleAlertNotification.hide();
            return this.saveNotification.hide();
        };

        Problem.prototype.gentle_alert = function (msg) {
            edx.HtmlUtils.setHtml(this.el.find('.notification-gentle-alert .notification-message'), edx.HtmlUtils.HTML(msg));
            this.clear_all_notifications();
            this.gentleAlertNotification.show();
            return this.gentleAlertNotification.focus();
        };

        Problem.prototype.save = function () {
            if (!this.submit_save_waitfor(this.save_internal)) {
                return this.disableAllButtonsWhileRunning(this.save_internal, false);
            }
        };

        Problem.prototype.save_internal = function () {
            var _this = this;
            Logger.log('problem_save', this.answers);
            return $.postWithPrefix("" + this.url + "/problem_save", this.answers, function (response) {
                var saveMessage;
                saveMessage = response.msg;
                if (response.success) {
                    _this.el.trigger('contentChanged', [_this.id, response.html]);
                    edx.HtmlUtils.setHtml(_this.el.find('.notification-save .notification-message'), edx.HtmlUtils.HTML(saveMessage));
                    _this.clear_all_notifications();
                    _this.saveNotification.show();
                    return _this.focus_on_save_notification();
                } else {
                    return _this.gentle_alert(saveMessage);
                }
            });
        };

        Problem.prototype.refreshMath = function (event, element) {
            var elid, eqn, jax, mathjax_preprocessor, preprocessor_tag, target;
            if (!element) {
                element = event.target;
            }
            elid = element.id.replace(/^input_/, '');
            target = "display_" + elid;
            preprocessor_tag = "inputtype_" + elid;
            mathjax_preprocessor = this.inputtypeDisplays[preprocessor_tag];
            if ((typeof MathJax !== "undefined" && MathJax !== null) && (jax = MathJax.Hub.getAllJax(target)[0])) {
                eqn = $(element).val();
                if (mathjax_preprocessor) {
                    eqn = mathjax_preprocessor(eqn);
                }
                MathJax.Hub.Queue(['Text', jax, eqn], [this.updateMathML, jax, element]);
            }
        };

        Problem.prototype.updateMathML = function (jax, element) {
            try {
                return $("#" + element.id + "_dynamath").val(jax.root.toMathML(''));
            } catch (exception) {
                if (!exception.restart) {
                    throw exception;
                }
                if (typeof MathJax !== "undefined" && MathJax !== null) {
                    return MathJax.Callback.After([this.refreshMath, jax], exception.restart);
                }
            }
        };

        Problem.prototype.refreshAnswers = function () {
            this.$('input.schematic').each(function (index, element) {
                return element.schematic.update_value();
            });
            this.$(".CodeMirror").each(function (index, element) {
                if (element.CodeMirror.save) {
                    return element.CodeMirror.save();
                }
            });
            return this.answers = this.inputs.serialize();
        };

        Problem.prototype.submitAnswersAndSubmitButton = function (bind) {
            var answered, at_least_one_text_input_found, one_text_input_filled,
                _this = this;
            if (bind == null) {
                bind = false;
            }
            "Used to check available answers and if something is checked (or the answer is set in some textbox)\n\"Submit\" button becomes enabled. Otherwise it is disabled by default.\n\nArguments:\n  bind (bool): used on the first check to attach event handlers to input fields\n   to change \"Submit\" enable status in case of some manipulations with answers";
            answered = true;
            at_least_one_text_input_found = false;
            one_text_input_filled = false;
            this.el.find("input:text").each(function (i, text_field) {
                if ($(text_field).is(':visible')) {
                    at_least_one_text_input_found = true;
                    if ($(text_field).val() !== '') {
                        one_text_input_filled = true;
                    }
                    if (bind) {
                        $(text_field).on('input', function (e) {
                            _this.saveNotification.hide();
                            _this.submitAnswersAndSubmitButton();
                        });
                    }
                }
            });
            if (at_least_one_text_input_found && !one_text_input_filled) {
                answered = false;
            }
            this.el.find(".choicegroup").each(function (i, choicegroup_block) {
                var checked;
                checked = false;
                $(choicegroup_block).find("input[type=checkbox], input[type=radio]").each(function (j, checkbox_or_radio) {
                    if ($(checkbox_or_radio).is(':checked')) {
                        checked = true;
                    }
                    if (bind) {
                        $(checkbox_or_radio).on('click', function (e) {
                            _this.saveNotification.hide();
                            _this.submitAnswersAndSubmitButton();
                        });
                    }
                });
                if (!checked) {
                    answered = false;
                }
            });
            this.el.find("select").each(function (i, select_field) {
                var selected_option;
                selected_option = $(select_field).find("option:selected").text().trim();
                if (selected_option === 'Select an option') {
                    answered = false;
                }
                if (bind) {
                    $(select_field).on('change', function (e) {
                        _this.saveNotification.hide();
                        _this.submitAnswersAndSubmitButton();
                    });
                }
            });
            if (answered) {
                return this.enableSubmitButton(true);
            } else {
                return this.enableSubmitButton(false, false);
            }
        };

        Problem.prototype.bindResetCorrectness = function () {
            var $inputtypes,
                _this = this;
            $inputtypes = this.el.find(".capa_inputtype").add(this.el.find(".inputtype"));
            return $inputtypes.each(function (index, inputtype) {
                var bindMethod, classes, cls, _i, _len, _results;
                classes = $(inputtype).attr('class').split(' ');
                _results = [];
                for (_i = 0, _len = classes.length; _i < _len; _i++) {
                    cls = classes[_i];
                    bindMethod = _this.bindResetCorrectnessByInputtype[cls];
                    if (bindMethod != null) {
                        _results.push(bindMethod(inputtype));
                    } else {
                        _results.push(void 0);
                    }
                }
                return _results;
            });
        };

        Problem.prototype.bindResetCorrectnessByInputtype = {
            formulaequationinput: function (element) {
                return $(element).find('input').on('input', function () {
                    var $p;
                    $p = $(element).find('span.status');
                    // Translators: the word unanswered here is about answering a problem the student must solve.;
                    return $p.parent().removeClass().addClass("unsubmitted");
                });
            },
            choicegroup: function (element) {
                var $element, id;
                $element = $(element);
                id = ($element.attr('id').match(/^inputtype_(.*)$/))[1];
                return $element.find('input').on('change', function () {
                    var $status;
                    $status = $("#status_" + id);
                    if ($status[0]) {
                        $status.removeClass().addClass("unanswered");
                        $status.empty().css('display', 'inline-block');
                    } else {
                        $("<span>", {
                            "class": "unanswered",
                            "style": "display: inline-block;",
                            "id": "status_" + id
                        });
                    }
                    return $element.find("label").removeClass();
                });
            },
            'option-input': function (element) {
                var $select, id;
                $select = $(element).find('select');
                id = ($select.attr('id').match(/^input_(.*)$/))[1];
                return $select.on('change', function () {
                    var $status;
                    return $status = $("#status_" + id).removeClass().addClass("unanswered").find('span').text(gettext('Status: unsubmitted'));
                });
            },
            textline: function (element) {
                return $(element).find('input').on('input', function () {
                    var $p;
                    $p = $(element).find('span.status');
                    // Translators: the word unanswered here is about answering a problem the student must solve.;
                    return $p.parent().removeClass("correct incorrect").addClass("unsubmitted");
                });
            }
        };

        Problem.prototype.inputtypeSetupMethods = {
            'text-input-dynamath': function (element) {
                /*
                 Return: function (eqn) -> eqn that preprocesses the user formula input before
                 it is fed into MathJax. Return 'false' if no preprocessor specified
                 */

                var data, preprocessor, preprocessorClass, preprocessorClassName;
                data = $(element).find('.text-input-dynamath_data');
                preprocessorClassName = data.data('preprocessor');
                preprocessorClass = window[preprocessorClassName];
                if (preprocessorClass == null) {
                    return false;
                } else {
                    preprocessor = new preprocessorClass();
                    return preprocessor.fn;
                }
            },
            javascriptinput: function (element) {
                var container, data, display, displayClass, evaluation, params, problemState, submission, submissionField;
                data = $(element).find(".javascriptinput_data");
                params = data.data("params");
                submission = data.data("submission");
                evaluation = data.data("evaluation");
                problemState = data.data("problem_state");
                displayClass = window[data.data('display_class')];
                if (evaluation === '') {
                    evaluation = null;
                }
                container = $(element).find(".javascriptinput_container");
                submissionField = $(element).find(".javascriptinput_input");
                display = new displayClass(problemState, submission, evaluation, container, submissionField, params);
                display.render();
                return display;
            },
            cminput: function (container) {
                var CodeMirrorEditor, CodeMirrorTextArea, element, id, linenumbers, mode, spaces, tabsize;
                element = $(container).find("textarea");
                tabsize = element.data("tabsize");
                mode = element.data("mode");
                linenumbers = element.data("linenums");
                spaces = Array(parseInt(tabsize) + 1).join(" ");
                CodeMirrorEditor = CodeMirror.fromTextArea(element[0], {
                    lineNumbers: linenumbers,
                    indentUnit: tabsize,
                    tabSize: tabsize,
                    mode: mode,
                    matchBrackets: true,
                    lineWrapping: true,
                    indentWithTabs: false,
                    smartIndent: false,
                    extraKeys: {
                        "Esc": function (cm) {
                            $(".grader-status").focus();
                            return false;
                        },
                        "Tab": function (cm) {
                            cm.replaceSelection(spaces, "end");
                            return false;
                        }
                    }
                });
                id = element.attr("id").replace(/^input_/, "");
                CodeMirrorTextArea = CodeMirrorEditor.getInputField();
                CodeMirrorTextArea.setAttribute("id", "cm-textarea-" + id);
                CodeMirrorTextArea.setAttribute("aria-describedby", "cm-editor-exit-message-" + id + " status_" + id);
                return CodeMirrorEditor;
            }
        };

        Problem.prototype.inputtypeShowAnswerMethods = {
            choicegroup: function (element, display, answers) {
                var answer, choice, input_id, _i, _len, _results;
                element = $(element);
                input_id = element.attr('id').replace(/inputtype_/, '');
                answer = answers[input_id];
                _results = [];
                for (_i = 0, _len = answer.length; _i < _len; _i++) {
                    choice = answer[_i];
                    _results.push(element.find("#input_" + input_id + "_" + choice).parent("label").addClass('choicegroup_correct'));
                }
                return _results;
            },
            javascriptinput: function (element, display, answers) {
                var answer, answer_id;
                answer_id = $(element).attr('id').split("_").slice(1).join("_");
                answer = JSON.parse(answers[answer_id]);
                return display.showAnswer(answer);
            },
            choicetextgroup: function (element, display, answers) {
                var answer, choice, input_id, _i, _len, _results;
                element = $(element);
                input_id = element.attr('id').replace(/inputtype_/, '');
                answer = answers[input_id];
                _results = [];
                for (_i = 0, _len = answer.length; _i < _len; _i++) {
                    choice = answer[_i];
                    _results.push(element.find("section#forinput" + choice).addClass('choicetextgroup_show_correct'));
                }
                return _results;
            },
            imageinput: function (element, display, answers) {
                var canvas, container, ctx, id, types;
                types = {
                    rectangle: function (ctx, coords) {
                        var rects, reg;
                        reg = /^\(([0-9]+),([0-9]+)\)-\(([0-9]+),([0-9]+)\)$/;
                        rects = coords.replace(/\s*/g, '').split(/;/);
                        $.each(rects, function (index, rect) {
                            var abs, height, points, width;
                            abs = Math.abs;
                            points = reg.exec(rect);
                            if (points) {
                                width = abs(points[3] - points[1]);
                                height = abs(points[4] - points[2]);
                                return ctx.rect(points[1], points[2], width, height);
                            }
                        });
                        ctx.stroke();
                        return ctx.fill();
                    },
                    regions: function (ctx, coords) {
                        var parseCoords;
                        parseCoords = function (coords) {
                            var reg;
                            reg = JSON.parse(coords);
                            if (typeof reg[0][0][0] === "undefined") {
                                reg = [reg];
                            }
                            return reg;
                        };
                        return $.each(parseCoords(coords), function (index, region) {
                            ctx.beginPath();
                            $.each(region, function (index, point) {
                                if (index === 0) {
                                    return ctx.moveTo(point[0], point[1]);
                                } else {
                                    return ctx.lineTo(point[0], point[1]);
                                }
                            });
                            ctx.closePath();
                            ctx.stroke();
                            return ctx.fill();
                        });
                    }
                };
                element = $(element);
                id = element.attr('id').replace(/inputtype_/, '');
                container = element.find("#answer_" + id);
                canvas = document.createElement('canvas');
                canvas.width = container.data('width');
                canvas.height = container.data('height');
                if (canvas.getContext) {
                    ctx = canvas.getContext('2d');
                } else {
                    return console.log('Canvas is not supported.');
                }
                ctx.fillStyle = 'rgba(255,255,255,.3)';
                ctx.strokeStyle = "#FF0000";
                ctx.lineWidth = "2";
                if (answers[id]) {
                    $.each(answers[id], function (key, value) {
                        if ((types[key] != null) && value) {
                            return types[key](ctx, value);
                        }
                    });
                    return container.html(canvas);
                } else {
                    return console.log("Answer is absent for image input with id=" + id);
                }
            }
        };

        Problem.prototype.inputtypeHideAnswerMethods = {
            choicegroup: function (element, display) {
                element = $(element);
                return element.find('label').removeClass('choicegroup_correct');
            },
            javascriptinput: function (element, display) {
                return display.hideAnswer();
            },
            choicetextgroup: function (element, display) {
                element = $(element);
                return element.find("section[id^='forinput']").removeClass('choicetextgroup_show_correct');
            }
        };

        Problem.prototype.disableAllButtonsWhileRunning = function (operationCallback, isFromCheckOperation) {
            var _this = this;
            this.enableAllButtons(false, isFromCheckOperation);
            return operationCallback().always(function () {
                return _this.enableAllButtons(true, isFromCheckOperation);
            });
        };

        Problem.prototype.enableAllButtons = function (enable, isFromCheckOperation) {
            if (enable) {
                this.resetButton.add(this.saveButton).add(this.hintButton).add(this.showButton).removeAttr('disabled');
            } else {
                this.resetButton.add(this.saveButton).add(this.hintButton).add(this.showButton).attr({
                    'disabled': 'disabled'
                });
            }
            return this.enableSubmitButton(enable, isFromCheckOperation);
        };

        Problem.prototype.enableSubmitButton = function (enable, changeText) {
            var submitCanBeEnabled;
            if (changeText == null) {
                changeText = true;
            }
            if (enable) {
                submitCanBeEnabled = this.submitButton.data('should-enable-submit-button') === 'True';
                if (submitCanBeEnabled) {
                    this.submitButton.removeAttr('disabled');
                }
                if (changeText) {
                    return this.submitButtonLabel.text(this.submitButtonSubmitText);
                }
            } else {
                this.submitButton.attr({
                    'disabled': 'disabled'
                });
                if (changeText) {
                    return this.submitButtonLabel.text(this.submitButtonSubmittingText);
                }
            }
        };

        Problem.prototype.enableSubmitButtonAfterResponse = function () {
            this.has_response = true;
            if (!this.has_timed_out) {
                return this.enableSubmitButton(false);
            } else {
                return this.enableSubmitButton(true);
            }
        };

        Problem.prototype.enableSubmitButtonAfterTimeout = function () {
            var enableSubmitButton,
                _this = this;
            this.has_timed_out = false;
            this.has_response = false;
            enableSubmitButton = function () {
                _this.has_timed_out = true;
                if (_this.has_response) {
                    return _this.enableSubmitButton(true);
                }
            };
            return window.setTimeout(enableSubmitButton, 750);
        };

        Problem.prototype.hint_button = function () {
            var hint_container, hint_index, next_index,
                _this = this;
            hint_container = this.$('.problem-hint');
            hint_index = hint_container.attr('hint_index');
            if (hint_index === void 0) {
                next_index = 0;
            } else {
                next_index = parseInt(hint_index) + 1;
            }
            return $.postWithPrefix("" + this.url + "/hint_button", {
                hint_index: next_index,
                input_id: this.id
            }, function (response) {
                var hint_msg_container;
                if (response.success) {
                    hint_msg_container = _this.$('.problem-hint .notification-message');
                    hint_container.attr('hint_index', response.hint_index);
                    edx.HtmlUtils.setHtml(hint_msg_container, edx.HtmlUtils.HTML(response.msg));
                    MathJax.Hub.Queue(['Typeset', MathJax.Hub, hint_container[0]]);
                    if (response.should_enable_next_hint) {
                        _this.hintButton.removeAttr('disabled');
                    } else {
                        _this.hintButton.attr({
                            'disabled': 'disabled'
                        });
                    }
                    _this.el.find('.notification-hint').show();
                    return _this.focus_on_hint_notification();
                } else {
                    return _this.gentle_alert(response.msg);
                }
            });
        };

        return Problem;

    }).call(this);

}).call(this);
