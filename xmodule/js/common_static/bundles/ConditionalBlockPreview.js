(function(e, a) { for(var i in a) e[i] = a[i]; }(window, webpackJsonp([32],{

/***/ "./common/static/xmodule/modules/js/001-879b5ca9f0c8ae80045af7486d8d310d.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($, _, $script) {/*** IMPORTS FROM imports-loader ***/
(function () {

  // Once generated by CoffeeScript 1.9.3, but now lives as pure JS
  /* eslint-disable */
  (function () {
    this.Conditional = function () {
      function Conditional(element, runtime, callerElId) {
        var dependencies;
        this.el = $(element).find('.conditional-wrapper');
        this.callerElId = callerElId;
        if (callerElId !== void 0) {
          dependencies = this.el.data('depends');
          if (typeof dependencies === 'string' && dependencies.length > 0 && dependencies.indexOf(callerElId) === -1) {
            return;
          }
        }
        this.url = this.el.data('url');
        if (this.url) {
          this.render(element);
        }
      }

      Conditional.prototype.render = function (element) {
        return $.postWithPrefix(this.url + "/conditional_get", function (_this) {
          return function (response) {
            var i,
                len,
                parentEl,
                parentId,
                ref,
                renderedFragments = [];
            _this.el.html('');
            fragments = response.fragments;
            for (i = 0, len = fragments.length; i < len; i++) {
              renderedFragments.push(_this.renderXBlockFragment(fragments[i]));
              console.log("Started fragment loading", fragments[i]);
            }
            parentEl = $(element).parent();
            parentId = parentEl.attr('id');
            if (response.message === false) {
              if (parentEl.hasClass('vert')) {
                parentEl.hide();
              } else {
                $(element).hide();
              }
            } else {
              if (parentEl.hasClass('vert')) {
                parentEl.show();
              } else {
                $(element).show();
              }
            }

            /*
            The children are rendered with a new request, so they have a different request-token.
            Use that token instead of @requestToken by simply not passing a token into initializeBlocks.
            */
            $.when.apply(null, renderedFragments).done(function () {
              console.log("All fragments loaded, initializing blocks");
              XBlock.initializeBlocks(_this.el);
            });
          };
        }(this));
      };

      /**
      * Renders an xblock fragment into the specified element. The fragment has two attributes:
      *   html: the HTML to be rendered
      *   resources: any JavaScript or CSS resources that the HTML depends upon
      * Note that the XBlock is rendered asynchronously, and so a promise is returned that
      * represents this process.
      * @param fragment The fragment returned from the xblock_handler
      * @returns {Promise} A promise representing the rendering process
      */
      Conditional.prototype.renderXBlockFragment = function (fragment) {
        var html = fragment.content,
            resources = fragment.resources || [],
            element = this.el;
        // Render the HTML first as the scripts might depend upon it, and then
        // asynchronously add the resources to the page. Any errors that are thrown
        // by included scripts are logged to the console but are then ignored assuming
        // that at least the rendered HTML will be in place.
        try {
          return this.addXBlockFragmentResources(resources).done(function () {
            // We give XBlock fragments free-reign to add javascript and CSS to
            // to the page, so XSS escaping doesn't matter much in this context
            console.log("Fragment resources loaded, appending HTML");
            // xss-lint: disable=javascript-jquery-append
            element.append(html);
          });
        } catch (e) {
          console.error(e, e.stack);
          return $.Deferred().resolve();
        }
      };

      /**
      * Dynamically loads all of an XBlock's dependent resources. This is an asynchronous
      * process so a promise is returned.
      * @param resources The resources to be rendered
      * @returns {Promise} A promise representing the rendering process
      */
      Conditional.prototype.addXBlockFragmentResources = function (resources) {
        var self = this;
        var _applyResource;
        var numResources;
        var deferred;
        var numResources = resources.length;
        var deferred = $.Deferred();

        _applyResource = function applyResource(index) {
          var hash, resource, value, promise;
          if (index >= numResources) {
            deferred.resolve();
            return;
          }
          resource = resources[index];
          window.loadedXBlockResources = window.loadedXBlockResources || [];
          if (_.indexOf(loadedXBlockResources, resource) < 0) {
            promise = self.loadResource(resource);
            loadedXBlockResources.push(resource);
            promise.done(function () {
              _applyResource(index + 1);
            }).fail(function () {
              deferred.reject();
            });
          } else {
            _applyResource(index + 1);
          }
        };
        _applyResource(0);
        return deferred.promise();
      };

      /**
      * Loads the specified resource into the page.
      * @param resource The resource to be loaded.
      * @returns {Promise} A promise representing the loading of the resource.
      */
      Conditional.prototype.loadResource = function (resource) {
        // We give XBlock fragments free-reign to add javascript and CSS to
        // to the page, so XSS escaping doesn't matter much in this context
        var $head = $('head'),
            mimetype = resource.mimetype,
            kind = resource.kind,
            placement = resource.placement,
            data = resource.data;
        var loaded;
        if (mimetype === 'text/css') {
          if (kind === 'text') {
            // xss-lint: disable=javascript-jquery-append,javascript-concat-html
            $head.append("<style type='text/css'>" + data + '</style>');
          } else if (kind === 'url') {
            // xss-lint: disable=javascript-jquery-append,javascript-concat-html
            $head.append("<link rel='stylesheet' href='" + data + "' type='text/css'>");
          }
        } else if (mimetype === 'application/javascript') {
          if (kind === 'text') {
            // xss-lint: disable=javascript-jquery-append,javascript-concat-html
            $head.append('<script>' + data + '</script>');
          } else if (kind === 'url') {
            loaded = $.Deferred();
            $script(data, data, function () {
              loaded.resolve();
            });
            return loaded.promise();
          }
        } else if (mimetype === 'text/html') {
          if (placement === 'head') {
            // xss-lint: disable=javascript-jquery-append
            $head.append(data);
          }
        }
        // Return an already resolved promise for synchronous updates
        return $.Deferred().resolve().promise();
      };

      return Conditional;
    }();
  }).call(this);
}).call(window);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(1), __webpack_require__("./node_modules/scriptjs/dist/script.js")))

/***/ }),

/***/ "./common/static/xmodule/modules/js/002-3918b2d4f383c04fed8227cc9f523d6e.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {/*** IMPORTS FROM imports-loader ***/
(function () {

    (function () {
        'use strict';

        this.JavascriptLoader = function () {
            function JavascriptLoader() {}

            /**
             * Set of library functions that provide common interface for javascript loading
             * for all module types. All functionality provided by JavascriptLoader should take
             * place at module scope, i.e. don't run jQuery over entire page.
             *
             * executeModuleScripts:
             *     Scan the module ('el') for "script_placeholder"s, then:
             *
             *     1) Fetch each script from server
             *     2) Explicitly attach the script to the <head> of document
             *     3) Explicitly wait for each script to be loaded
             *     4) Return to callback function when all scripts loaded
             */
            JavascriptLoader.executeModuleScripts = function (el, callback) {
                var callbackCalled, completed, completionHandlerGenerator, loaded, placeholders;
                if (!callback) {
                    callback = null; // eslint-disable-line no-param-reassign
                }
                placeholders = el.find('.script_placeholder');
                if (placeholders.length === 0) {
                    if (callback !== null) {
                        callback();
                    }
                    return [];
                }
                // TODO: Verify the execution order of multiple placeholders
                completed = function () {
                    var i, ref, results;
                    results = [];
                    for (i = 1, ref = placeholders.length; ref >= 1 ? i <= ref : i >= ref; ref >= 1 ? ++i : --i) {
                        results.push(false);
                    }
                    return results;
                }();
                callbackCalled = false;
                completionHandlerGenerator = function completionHandlerGenerator(index) {
                    return function () {
                        var allComplete, flag, i, len;
                        allComplete = true;
                        completed[index] = true;
                        for (i = 0, len = completed.length; i < len; i++) {
                            flag = completed[i];
                            if (!flag) {
                                allComplete = false;
                                break;
                            }
                        }
                        if (allComplete && !callbackCalled) {
                            callbackCalled = true;
                            if (callback !== null) {
                                return callback();
                            }
                        }
                        return undefined;
                    };
                };
                // Keep a map of what sources we're loaded from, and don't do it twice.
                loaded = {};
                return placeholders.each(function (index, placeholder) {
                    var s, src;
                    // TODO: Check if the script already exists in DOM. If so, (1) copy it
                    // into memory; (2) delete the DOM script element; (3) reappend it.
                    // This would prevent memory bloat and save a network request.
                    src = $(placeholder).attr('data-src');
                    if (!(src in loaded)) {
                        loaded[src] = true;
                        s = document.createElement('script');
                        s.setAttribute('src', src);
                        s.setAttribute('type', 'text/javascript');
                        s.onload = completionHandlerGenerator(index);
                        // Need to use the DOM elements directly or the scripts won't execute properly.
                        $('head')[0].appendChild(s);
                    } else {
                        // just call the completion callback directly, without reloading the file
                        completionHandlerGenerator(index)();
                    }
                    return $(placeholder).remove();
                });
            };

            return JavascriptLoader;
        }();
    }).call(this);
}).call(window);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),

/***/ "./common/static/xmodule/modules/js/003-b3206f2283964743c4772b9d72c67d64.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($, __webpack_provided_edx_dot_HtmlUtils) {/*** IMPORTS FROM imports-loader ***/
(function () {

    (function (undefined) {
        'use strict';

        // [module Collapsible]
        //
        // [description]
        //     Set of library functions that provide a simple way to add
        //     collapsible functionality to elements.

        this.Collapsible = {
            setCollapsibles: setCollapsibles,
            toggleFull: toggleFull,
            toggleHint: toggleHint
        };

        return;

        // [function setCollapsibles]
        //
        // [description]
        //     Scan element's content for generic collapsible containers.
        //
        // [params]
        //     el: container
        function setCollapsibles(el) {
            var linkBottom, linkTop, short_custom;

            linkTop = '<a href="#" class="full full-top">See full output</a>';
            linkBottom = '<a href="#" class="full full-bottom">See full output</a>';

            // Standard longform + shortfom pattern.
            el.find('.longform').hide();
            el.find('.shortform').append(linkTop, linkBottom); // xss-lint: disable=javascript-jquery-append

            // Custom longform + shortform text pattern.
            short_custom = el.find('.shortform-custom');

            // Set up each one individually.
            short_custom.each(function (index, elt) {
                var close_text, open_text;

                open_text = $(elt).data('open-text');
                close_text = $(elt).data('close-text');
                __webpack_provided_edx_dot_HtmlUtils.append($(elt), __webpack_provided_edx_dot_HtmlUtils.joinHtml(__webpack_provided_edx_dot_HtmlUtils.HTML("<a href='#' class='full-custom'>"), gettext(open_text), __webpack_provided_edx_dot_HtmlUtils.HTML('</a>')));

                $(elt).find('.full-custom').click(function (event) {
                    Collapsible.toggleFull(event, open_text, close_text);
                });
            });

            // Collapsible pattern.
            el.find('.collapsible header + section').hide();

            // Set up triggers.
            el.find('.full').click(function (event) {
                Collapsible.toggleFull(event, 'See full output', 'Hide output');
            });
            el.find('.collapsible header a').click(Collapsible.toggleHint);
        }

        // [function toggleFull]
        //
        // [description]
        //     Toggle the display of full text for a collapsible element.
        //
        // [params]
        //     event: jQuery event object associated with the event that
        //         triggered this callback function.
        //     open_text: text that should be displayed when the collapsible
        //         is open.
        //     close_text: text that should be displayed when the collapsible
        //         is closed.
        function toggleFull(event, open_text, close_text) {
            var $el, new_text, parent;

            event.preventDefault();

            parent = $(event.target).parent();
            parent.siblings().slideToggle();
            parent.parent().toggleClass('open');

            if ($(event.target).text() === open_text) {
                new_text = close_text;
            } else {
                new_text = open_text;
            }

            if ($(event.target).hasClass('full')) {
                $el = parent.find('.full');
            } else {
                $el = $(event.target);
            }

            $el.text(new_text);
        }

        // [function toggleHint]
        //
        // [description]
        //     Toggle the collapsible open to show the hint.
        //
        // [params]
        //     event: jQuery event object associated with the event that
        //         triggered this callback function.
        function toggleHint(event) {
            event.preventDefault();

            $(event.target).parent().siblings().slideToggle();
            $(event.target).parent().parent().toggleClass('open');
        }
    }).call(this);
}).call(window);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__("./node_modules/edx-ui-toolkit/src/js/utils/html-utils.js")))

/***/ }),

/***/ "./node_modules/scriptjs/dist/script.js":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
  * $script.js JS loader & dependency manager
  * https://github.com/ded/script.js
  * (c) Dustin Diaz 2014 | License MIT
  */

(function (name, definition) {
  if (typeof module != 'undefined' && module.exports) module.exports = definition()
  else if (true) !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
  else this[name] = definition()
})('$script', function () {
  var doc = document
    , head = doc.getElementsByTagName('head')[0]
    , s = 'string'
    , f = false
    , push = 'push'
    , readyState = 'readyState'
    , onreadystatechange = 'onreadystatechange'
    , list = {}
    , ids = {}
    , delay = {}
    , scripts = {}
    , scriptpath
    , urlArgs

  function every(ar, fn) {
    for (var i = 0, j = ar.length; i < j; ++i) if (!fn(ar[i])) return f
    return 1
  }
  function each(ar, fn) {
    every(ar, function (el) {
      return !fn(el)
    })
  }

  function $script(paths, idOrDone, optDone) {
    paths = paths[push] ? paths : [paths]
    var idOrDoneIsDone = idOrDone && idOrDone.call
      , done = idOrDoneIsDone ? idOrDone : optDone
      , id = idOrDoneIsDone ? paths.join('') : idOrDone
      , queue = paths.length
    function loopFn(item) {
      return item.call ? item() : list[item]
    }
    function callback() {
      if (!--queue) {
        list[id] = 1
        done && done()
        for (var dset in delay) {
          every(dset.split('|'), loopFn) && !each(delay[dset], loopFn) && (delay[dset] = [])
        }
      }
    }
    setTimeout(function () {
      each(paths, function loading(path, force) {
        if (path === null) return callback()
        
        if (!force && !/^https?:\/\//.test(path) && scriptpath) {
          path = (path.indexOf('.js') === -1) ? scriptpath + path + '.js' : scriptpath + path;
        }
        
        if (scripts[path]) {
          if (id) ids[id] = 1
          return (scripts[path] == 2) ? callback() : setTimeout(function () { loading(path, true) }, 0)
        }

        scripts[path] = 1
        if (id) ids[id] = 1
        create(path, callback)
      })
    }, 0)
    return $script
  }

  function create(path, fn) {
    var el = doc.createElement('script'), loaded
    el.onload = el.onerror = el[onreadystatechange] = function () {
      if ((el[readyState] && !(/^c|loade/.test(el[readyState]))) || loaded) return;
      el.onload = el[onreadystatechange] = null
      loaded = 1
      scripts[path] = 2
      fn()
    }
    el.async = 1
    el.src = urlArgs ? path + (path.indexOf('?') === -1 ? '?' : '&') + urlArgs : path;
    head.insertBefore(el, head.lastChild)
  }

  $script.get = create

  $script.order = function (scripts, id, done) {
    (function callback(s) {
      s = scripts.shift()
      !scripts.length ? $script(s, id, done) : $script(s, callback)
    }())
  }

  $script.path = function (p) {
    scriptpath = p
  }
  $script.urlArgs = function (str) {
    urlArgs = str;
  }
  $script.ready = function (deps, ready, req) {
    deps = deps[push] ? deps : [deps]
    var missing = [];
    !each(deps, function (dep) {
      list[dep] || missing[push](dep);
    }) && every(deps, function (dep) {return list[dep]}) ?
      ready() : !function (key) {
      delay[key] = delay[key] || []
      delay[key][push](ready)
      req && req(missing)
    }(deps.join('|'))
    return $script
  }

  $script.done = function (idOrDone) {
    $script([null], idOrDone)
  }

  return $script
});


/***/ }),

/***/ 19:
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./common/static/xmodule/modules/js/000-b82f6c436159f6bc7ca2513e29e82503.js");
__webpack_require__("./common/static/xmodule/modules/js/001-879b5ca9f0c8ae80045af7486d8d310d.js");
__webpack_require__("./common/static/xmodule/modules/js/002-3918b2d4f383c04fed8227cc9f523d6e.js");
module.exports = __webpack_require__("./common/static/xmodule/modules/js/003-b3206f2283964743c4772b9d72c67d64.js");


/***/ })

},[19])));
//# sourceMappingURL=ConditionalBlockPreview.js.map